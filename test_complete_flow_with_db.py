#!/usr/bin/env python3
"""
Complete Flow Test with Database Validation
Tests the ENTIRE trading flow: Order ‚Üí Exchange ‚Üí Database ‚Üí Sync
Validates that orders are properly stored and tracked in the database
"""

import asyncio
import httpx
import json
from datetime import datetime, timedelta

# Test configuration
EXCHANGE_SERVICE_URL = "http://localhost:8003"
DATABASE_SERVICE_URL = "http://localhost:8002"
TEST_AMOUNT_USDC = 10.0

async def get_trades_by_entry_id(entry_id):
    """Get trade that matches a specific exchange order ID"""
    async with httpx.AsyncClient(timeout=30.0) as client:
        try:
            # Get all recent trades and filter by entry_id
            response = await client.get(f"{DATABASE_SERVICE_URL}/api/v1/trades", params={'limit': 50})
            if response.status_code == 200:
                trades_data = response.json()
                trades = trades_data.get('trades', [])
                # Look for trade with matching entry_id
                for trade in trades:
                    if trade.get('entry_id') == entry_id:
                        return trade
                return None
            else:
                print(f"‚ö†Ô∏è  Failed to get trades from database: {response.status_code}")
                return None
        except Exception as e:
            print(f"‚ö†Ô∏è  Database query error: {e}")
            return None

async def get_trades_from_database(exchange=None, limit=10):
    """Get recent trades from database"""
    async with httpx.AsyncClient(timeout=30.0) as client:
        try:
            params = {'limit': limit}
            if exchange:
                params['exchange'] = exchange
                
            response = await client.get(f"{DATABASE_SERVICE_URL}/api/v1/trades", params=params)
            if response.status_code == 200:
                return response.json()
            else:
                print(f"‚ö†Ô∏è  Failed to get trades from database: {response.status_code}")
                return None
        except Exception as e:
            print(f"‚ö†Ô∏è  Database trades query error: {e}")
            return None

async def wait_for_trade_in_database(entry_id, max_wait_seconds=15):
    """Wait for trade with specific entry_id to appear in database with polling"""
    print(f"   ‚è≥ Waiting for trade with entry_id {entry_id} to appear in database...")
    
    for attempt in range(max_wait_seconds):
        await asyncio.sleep(1)
        
        db_trade = await get_trades_by_entry_id(entry_id)
        if db_trade:
            print(f"   ‚úÖ Trade found in database after {attempt + 1}s")
            return db_trade
        
        print(f"   ‚è≥ Attempt {attempt + 1}/{max_wait_seconds}...")
    
    print(f"   ‚ùå Trade with entry_id {entry_id} not found in database after {max_wait_seconds}s")
    return None

async def test_complete_flow_with_database():
    """Test complete trading flow with database validation"""
    print("üóÑÔ∏è  COMPLETE FLOW TEST WITH DATABASE VALIDATION")
    print("‚ö†Ô∏è  WARNING: Tests real orders AND database storage!")
    print(f"üí∞ Test amount: ${TEST_AMOUNT_USDC} USDC")
    print("=" * 70)
    
    print("üìã This test validates:")
    print("   1Ô∏è‚É£ Order placement via Exchange Service API")
    print("   2Ô∏è‚É£ Order execution on Bybit exchange")
    print("   3Ô∏è‚É£ Order storage in PostgreSQL database")
    print("   4Ô∏è‚É£ Order status synchronization")
    print("   5Ô∏è‚É£ Trade record creation")
    print("   6Ô∏è‚É£ Balance updates in database")
    print()
    
    # Auto-confirm for automated testing
    print("‚ö†Ô∏è  Auto-confirming for automated test execution...")
    confirmation = 'YES'
    if confirmation != 'YES':
        print("‚ùå Complete flow test cancelled")
        return False

    async with httpx.AsyncClient(timeout=30.0) as client:
        try:
            # STEP 1: Get baseline database state
            print("\nüìä STEP 1: Getting baseline database state...")
            
            initial_trades = await get_trades_from_database(exchange='bybit', limit=5)
            
            initial_trade_count = len(initial_trades.get('trades', [])) if initial_trades else 0
            
            print(f"   üí± Initial trades in DB: {initial_trade_count}")
            
            # STEP 2: Get initial balances (exchange + database)
            print(f"\nüí∞ STEP 2: Getting initial balances...")
            
            # Exchange balance
            response = await client.get(f"{EXCHANGE_SERVICE_URL}/api/v1/account/balance/bybit")
            if response.status_code != 200:
                print(f"‚ùå Failed to get exchange balance")
                return False
            
            exchange_balance = response.json()
            initial_usdc_exchange = exchange_balance.get('free', {}).get('USDC', 0) or 0
            initial_btc_exchange = exchange_balance.get('free', {}).get('BTC', 0) or 0
            
            print(f"   üí∞ Exchange USDC: {initial_usdc_exchange:.2f}")
            print(f"   ü™ô Exchange BTC: {initial_btc_exchange:.8f}")
            
            # Database balance (if available)
            try:
                db_balance_response = await client.get(f"{DATABASE_SERVICE_URL}/api/v1/balances/bybit")
                if db_balance_response.status_code == 200:
                    db_balance = db_balance_response.json()
                    print(f"   üóÑÔ∏è  Database balance available: {db_balance.get('total', 'N/A')}")
                else:
                    print(f"   ‚ö†Ô∏è  Database balance not available: {db_balance_response.status_code}")
            except:
                print(f"   ‚ö†Ô∏è  Could not query database balance")
            
            if initial_usdc_exchange < TEST_AMOUNT_USDC:
                print(f"‚ùå Insufficient USDC: need ${TEST_AMOUNT_USDC}, have ${initial_usdc_exchange:.2f}")
                return False
            
            # STEP 3: Place BUY order and track in database
            print(f"\nüõí STEP 3: Placing BUY order with database tracking...")
            
            buy_order = {
                "exchange": "bybit",
                "symbol": "BTC/USDC",
                "order_type": "market",
                "side": "buy",
                "amount": TEST_AMOUNT_USDC,
                "price": None
            }
            
            print(f"   üì§ Placing buy order for ${TEST_AMOUNT_USDC} USDC...")
            buy_start = datetime.now()
            
            response = await client.post(f"{EXCHANGE_SERVICE_URL}/api/v1/trading/order", json=buy_order)
            buy_end = datetime.now()
            
            print(f"   ‚è±Ô∏è  Buy order response time: {(buy_end - buy_start).total_seconds():.2f}s")
            print(f"   üìä Buy order status: {response.status_code}")
            
            if response.status_code != 200:
                error_text = response.text
                print(f"   ‚ùå BUY ORDER FAILED!")
                print(f"   üìÑ Error: {error_text}")
                return False
            
            buy_result = response.json()
            buy_order_id = buy_result.get('id')
            buy_sync_status = buy_result.get('sync_status', 'unknown')
            
            print(f"   ‚úÖ BUY ORDER PLACED!")
            print(f"   üìã Order ID: {buy_order_id}")
            print(f"   üîÑ Sync Status: {buy_sync_status}")
            
            # STEP 4: Verify trade in database
            print(f"\nüóÑÔ∏è  STEP 4: Verifying buy order trade in database...")
            
            db_buy_trade = await wait_for_trade_in_database(buy_order_id, max_wait_seconds=15)
            
            if db_buy_trade:
                print(f"   ‚úÖ Buy trade found in database!")
                print(f"   üìã DB Trade ID: {db_buy_trade.get('trade_id', 'N/A')}")
                print(f"   üìà DB Status: {db_buy_trade.get('status', 'N/A')}")
                print(f"   üí∞ DB Position Size: {db_buy_trade.get('position_size', 'N/A')}")
                print(f"   üè™ DB Exchange: {db_buy_trade.get('exchange', 'N/A')}")
                print(f"   üìä DB Symbol: {db_buy_trade.get('pair', 'N/A')}")
                print(f"   üîó DB Entry ID: {db_buy_trade.get('entry_id', 'N/A')}")
                
                # Check if trade shows as open/successful
                db_status = db_buy_trade.get('status', '').upper()
                if db_status in ['OPEN']:
                    print(f"   ‚úÖ Trade shows as OPEN in database")
                elif db_status in ['FAILED']:
                    print(f"   ‚ùå Trade shows as FAILED in database!")
                    return False
                else:
                    print(f"   ‚è≥ Trade status: {db_status}")
            else:
                print(f"   ‚ùå Buy trade NOT found in database!")
                print(f"   üîß Database synchronization may have failed")
                # Continue test but flag the issue
            
            # STEP 5: Wait and check balances after buy
            print(f"\n‚è≥ STEP 5: Checking balances after buy order...")
            await asyncio.sleep(5)  # Wait for settlement
            
            response = await client.get(f"{EXCHANGE_SERVICE_URL}/api/v1/account/balance/bybit")
            if response.status_code == 200:
                after_buy_balance = response.json()
                after_buy_usdc = after_buy_balance.get('free', {}).get('USDC', 0) or 0
                after_buy_btc = after_buy_balance.get('free', {}).get('BTC', 0) or 0
                
                usdc_spent = initial_usdc_exchange - after_buy_usdc
                btc_received = after_buy_btc - initial_btc_exchange
                
                print(f"   üí∞ USDC after buy: {after_buy_usdc:.2f} (spent: {usdc_spent:.2f})")
                print(f"   ü™ô BTC after buy: {after_buy_btc:.8f} (received: {btc_received:.8f})")
                
                if btc_received <= 0:
                    print(f"   ‚ùå No BTC received - order may have failed")
                    return False
            
            # STEP 6: Check for trade records in database
            print(f"\nüí± STEP 6: Checking for trade records in database...")
            
            await asyncio.sleep(2)  # Wait for trade processing
            current_trades = await get_trades_from_database(exchange='bybit', limit=10)
            
            if current_trades:
                trades_list = current_trades.get('trades', [])
                new_trade_count = len(trades_list)
                print(f"   üìä Current trades in DB: {new_trade_count}")
                
                if new_trade_count > initial_trade_count:
                    new_trades = new_trade_count - initial_trade_count
                    print(f"   ‚úÖ {new_trades} new trade(s) detected in database")
                    
                    # Show latest trade
                    latest_trade = trades_list[0] if trades_list else None
                    if latest_trade:
                        print(f"   üìã Latest trade:")
                        print(f"      Trade ID: {latest_trade.get('trade_id', 'N/A')}")
                        print(f"      Symbol: {latest_trade.get('pair', 'N/A')}")
                        print(f"      Exchange: {latest_trade.get('exchange', 'N/A')}")
                        print(f"      Position Size: {latest_trade.get('position_size', 'N/A')}")
                        print(f"      Entry Price: {latest_trade.get('entry_price', 'N/A')}")
                        print(f"      Status: {latest_trade.get('status', 'N/A')}")
                else:
                    print(f"   ‚ö†Ô∏è  No new trades detected in database")
            else:
                print(f"   ‚ö†Ô∏è  Could not query trades from database")
            
            # STEP 7: Test SELL order with database tracking
            print(f"\nüí∏ STEP 7: Testing SELL order with database tracking...")
            
            # Use most of the BTC we received (account for fees)
            btc_to_sell = btc_received * 0.95
            
            sell_order = {
                "exchange": "bybit",
                "symbol": "BTC/USDC",
                "order_type": "market",
                "side": "sell", 
                "amount": btc_to_sell,
                "price": None
            }
            
            print(f"   üì§ Placing sell order for {btc_to_sell:.8f} BTC...")
            
            response = await client.post(f"{EXCHANGE_SERVICE_URL}/api/v1/trading/order", json=sell_order)
            
            if response.status_code == 200:
                sell_result = response.json()
                sell_order_id = sell_result.get('id')
                sell_sync_status = sell_result.get('sync_status', 'unknown')
                
                print(f"   ‚úÖ SELL ORDER PLACED!")
                print(f"   üìã Sell Order ID: {sell_order_id}")
                print(f"   üîÑ Sync Status: {sell_sync_status}")
                
                # Verify sell order trade in database
                print(f"   üóÑÔ∏è  Verifying sell order in database...")
                db_sell_trade = await wait_for_trade_in_database(sell_order_id, max_wait_seconds=15)
                
                if db_sell_trade:
                    print(f"   ‚úÖ Sell order found in database!")
                    print(f"   üìà DB Status: {db_sell_trade.get('status', 'N/A')}")
                    print(f"   üîó DB Exit ID: {db_sell_trade.get('exit_id', 'N/A')}")
                else:
                    print(f"   ‚ùå Sell order NOT found in database!")
            else:
                print(f"   ‚ùå SELL ORDER FAILED: {response.status_code}")
                print(f"   üìÑ Error: {response.text}")
                return False
            
            # STEP 8: Final validation
            print(f"\nüìä STEP 8: Final database validation...")
            
            await asyncio.sleep(3)
            
            final_trades = await get_trades_from_database(exchange='bybit', limit=10)
            
            final_trade_count = len(final_trades.get('trades', [])) if final_trades else 0
            
            trades_added = final_trade_count - initial_trade_count
            
            print(f"   üí± Trades added to DB: {trades_added}")
            
            # Success criteria
            exchange_success = buy_order_id and sell_order_id
            database_trades = trades_added >= 1   # At least one trade record (buy creates, sell updates)
            database_sync = db_buy_trade is not None  # Buy order was properly synced
            
            print(f"\nüéØ VALIDATION RESULTS:")
            print(f"   Exchange Orders: {'‚úÖ' if exchange_success else '‚ùå'}")
            print(f"   Database Trades: {'‚úÖ' if database_trades else '‚ùå'} ({trades_added} added)")
            print(f"   Database Sync: {'‚úÖ' if database_sync else '‚ùå'}")
            
            if exchange_success and database_sync:
                print(f"\nüéâ COMPLETE FLOW WITH DATABASE TEST PASSED!")
                print(f"   ‚úÖ Orders successfully placed on exchange")
                print(f"   ‚úÖ Orders properly stored in database") 
                print(f"   ‚úÖ Database synchronization working")
                if database_trades:
                    print(f"   ‚úÖ Trade records created in database")
                print(f"   üöÄ Complete trading flow validated!")
                return True
            else:
                print(f"\n‚ö†Ô∏è  Partial success - some database integration issues")
                return False
                
        except Exception as e:
            print(f"‚ùå Complete flow test failed: {e}")
            return False

async def main():
    """Run the complete flow test with database validation"""
    print(f"üß™ Complete Trading Flow + Database Validation Test")
    print(f"‚è∞ Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    success = await test_complete_flow_with_database()
    
    print("\n" + "=" * 70)
    if success:
        print("üéâ COMPLETE FLOW + DATABASE TEST PASSED!")
        print("‚úÖ Order placement working correctly")
        print("‚úÖ Database storage and synchronization working")
        print("‚úÖ Trade records being created")
        print("‚úÖ Complete end-to-end flow validated")
        print("üöÄ System ready for production with full database tracking")
    else:
        print("‚ùå COMPLETE FLOW + DATABASE TEST FAILED!")
        print("üîß Issues detected in order processing or database sync")
        print("üìã Check detailed logs above for specific failures")
    
    print(f"‚è∞ Completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    asyncio.run(main())